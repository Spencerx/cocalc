/*


 echo "require('@cocalc/database/nats').init()" | COCALC_MODE='single-user' DEBUG_CONSOLE=yes DEBUG=cocalc:* node

*/

import getLogger from "@cocalc/backend/logger";
import { JSONCodec } from "nats";
import userQuery from "@cocalc/database/user-query";
import { getConnection } from "@cocalc/backend/nats";
import { getUserId } from "@cocalc/nats/api";
import { callback } from "awaiting";
import { db } from "@cocalc/database";
import {
  createSyncTable,
  CHANGEFEED_INTEREST_PERIOD_MS,
} from "@cocalc/nats/sync/synctable";
import { sha1 } from "@cocalc/backend/misc_node";
import jsonStableStringify from "json-stable-stringify";
import { reuseInFlight } from "@cocalc/util/reuse-in-flight";
import { uuid } from "@cocalc/util/misc";
import { delay } from "awaiting";

const logger = getLogger("database:nats");

const jc = JSONCodec();

export async function init() {
  const subject = "hub.*.*.db";
  logger.debug(`init -- subject='${subject}', options=`, {
    queue: "0",
  });
  const nc = await getConnection();
  const sub = nc.subscribe(subject, { queue: "0" });
  for await (const mesg of sub) {
    handleRequest(mesg, nc);
  }
}

async function handleRequest(mesg, nc) {
  console.log({ subject: mesg.subject });
  let resp;
  try {
    const { account_id, project_id } = getUserId(mesg.subject);
    const { name, args } = jc.decode(mesg.data) ?? ({} as any);
    if (!name) {
      throw Error("api endpoint name must be given in message");
    }
    logger.debug("handling hub db request:", {
      account_id,
      project_id,
      name,
      args,
    });
    resp = await getResponse({ name, args, account_id, project_id, nc });
  } catch (err) {
    resp = { error: `${err}` };
  }
  mesg.respond(jc.encode(resp));
}

async function getResponse({ name, args, account_id, project_id, nc }) {
  if (name == "userQuery") {
    const opts = { ...args[0], account_id, project_id };
    if (!opts.changes) {
      // a normal query
      return await userQuery(opts);
    } else {
      return await createChangefeed(opts, nc);
    }
  } else {
    throw Error(`name='${name}' not implemented`);
  }
}

// This is tricky.  We return the first result as a normal
// async function, but then handle (and don't return)
// the subsequent calls to cb generated by the changefeed.
const changefeedInterest: { [hash: string]: number } = {};

const createChangefeed = reuseInFlight(
  async (opts, nc) => {
    const query = opts.query;
    const hash = sha1(jsonStableStringify(query));
    const now = Date.now();
    if (changefeedInterest[hash]) {
      changefeedInterest[hash] = now;
      logger.debug("using existing changefeed for", query);
      return;
    }
    logger.debug("creating new changefeed for", query);
    const changes = uuid();
    const env = { nc, jc, sha1 };
    const synctable = createSyncTable({
      query,
      env,
      account_id: opts.account_id,
      project_id: opts.project_id,
      atomic: true,
    });
    await synctable.init();
    const f = (cb) => {
      let first = true;
      db().user_query({
        ...opts,
        changes,
        cb: async (err, result) => {
          if (first) {
            first = false;
            cb(err);
            if (result != null) {
              for (const x of result[synctable.table]) {
                logger.debug("changefeed init", x);
                await synctable.set(x);
              }
            }
            return;
          }
          logger.debug("changefeed", result);
          const { action, new_val, old_val } = result as any;
          // action = 'insert', 'update', 'delete', 'close'
          // e.g., {"action":"insert","new_val":{"title":"testingxxxxx","project_id":"81e0c408-ac65-4114-bad5-5f4b6539bd0e"}}
          if (action == "insert") {
            await synctable.set(new_val);
          } else if (action == "update") {
            // update -- since atomic have to get the current value;
            // this of course assumes there is one process writing to
            // this part of the key value store (the atomic business).
            await synctable.set({
              ...(await synctable.get(new_val)),
              ...new_val,
            });
          } else if (action == "delete") {
            await synctable.delete(old_val);
          } else if (action == "close") {
            delete changefeedInterest[hash];
          }
        },
      });
    };
    try {
      await callback(f);
      // it's running successfully
      changefeedInterest[hash] = Date.now();

      const watch = async () => {
        // it's all setup and running.  If there's no interest for a while, stop watching
        while (true) {
          await delay(CHANGEFEED_INTEREST_PERIOD_MS);
          if (
            Date.now() - changefeedInterest[hash] >
            CHANGEFEED_INTEREST_PERIOD_MS
          ) {
            logger.debug(
              "insufficient interest in the changefeed, so we stop it.",
              query,
            );
            db().user_query_cancel_changefeed({ id: changes });
            delete changefeedInterest[hash];
          }
        }
      };
      // do not block on this.
      watch();
      return;
    } catch (err) {
      throw err;
    }
  },
  { createKey: (args) => jsonStableStringify(args[0]) },
);
